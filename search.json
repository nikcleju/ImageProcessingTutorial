[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ImgProcBasics",
    "section": "",
    "text": "This is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "Overview.html",
    "href": "Overview.html",
    "title": "1  Overview",
    "section": "",
    "text": "Geometric Transformations\nLinear filtering\nImage binarization\n\nHistogram equalization\nThresholding\nAdaptive thresholding\nOtsu’s method\n\nMorphological operations"
  },
  {
    "objectID": "GeometricTransformations.html",
    "href": "GeometricTransformations.html",
    "title": "2  Geometric Transformations",
    "section": "",
    "text": "Geometry transformations\n\n\n\nimage from: https://learnopencv.com/warp-one-triangle-to-another-using-opencv-c-python/\n\nIn detail:\n\nRotations (Euclidean)\nAffine transformations (skew)\nPerspective transformations (homography)\n\nAny transformation = a function \\(T(\\dot)\\) which transforms a pixel’s original location \\(\\begin{bmatrix} x \\\\ y \\end{bmatrix}\\) into the destination location \\(\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\\)\n\\[\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=T\\left(\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n\\right)\\]"
  },
  {
    "objectID": "GeometricTransformations.html#comparison",
    "href": "GeometricTransformations.html#comparison",
    "title": "2  Geometric Transformations",
    "section": "2.2 Comparison",
    "text": "2.2 Comparison\nWhat stays unchanged?\n\n\n\nGeometry transformations\n\n\nRotation:\n\nLines remain lines, parallel remains parallel, angles are same, distances are same\n\nAffine (skew):\n\nLines remain lines, parallel remains parallel, angles change, distances change\n\nPerspective:\n\nLines remain lines, angles change, distances change, parallel remains parallel along one direction, converge to a point along other direction"
  },
  {
    "objectID": "GeometricTransformations.html#rotations",
    "href": "GeometricTransformations.html#rotations",
    "title": "2  Geometric Transformations",
    "section": "2.3 Rotations",
    "text": "2.3 Rotations\n\n\n\nRotation (and translation)\n\n\n\nimage from: https://mikamustonen.com/2019-06-22-how-to-rotate-an-image-with-opencv.html\n\nEquation:\n\\[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\n=\n\\begin{bmatrix}\n\\cos{\\alpha} & -\\sin{\\alpha} \\\\\n\\sin{\\alpha} & \\cos{\\alpha} \\\\\n\\end{bmatrix}\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n+\n\\begin{bmatrix} t_1 \\\\ t_2 \\end{bmatrix}\n\\]\n\nThis includes a translation with \\(\\begin{bmatrix} t_1 \\\\ t_2 \\end{bmatrix}\\).\nAlternatively, we can drop \\(\\begin{bmatrix} t_1 \\\\ t_2 \\end{bmatrix}\\), and we can pick the origin \\(\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\) where we want\n\n\n2.3.1 Alternate equation\n\\[\\begin{bmatrix} x' \\\\ y' \\\\ 1\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\cos{\\alpha} & -\\sin{\\alpha} & t_1\\\\\n\\sin{\\alpha} & \\cos{\\alpha}  & t_2\\\\\n0 & 0  & 1\\\\\n\\end{bmatrix}\n\\begin{bmatrix} x \\\\ y \\\\ 1\\end{bmatrix}\n\\]\n\n\n2.3.2 Rotation: Sample\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Display original\nI = cv2.imread('img/lena512.bmp')\nplt.imshow(I)\n\n<matplotlib.image.AxesImage at 0x7fd834050280>\n\n\n\n\n\n\n# Rotate with OpenCV\nangle = 25\n#fixed_point = tuple(np.array(I.shape[1::-1]) / 2)\n#fixed_point = tuple([50, 50])\nfixed_point = tuple([0, 0])\n\nrot_mat = cv2.getRotationMatrix2D(fixed_point, angle, 1.0)\nIrot = cv2.warpAffine(I, rot_mat, I.shape[1::-1], flags=cv2.INTER_LINEAR)\n\nprint(f\"Rotating around point {fixed_point}\")\nprint(f\"Rotation matrix is {rot_mat}\")\nplt.imshow(Irot)\n\nRotating around point (0, 0)\nRotation matrix is [[ 0.90630779  0.42261826  0.        ]\n [-0.42261826  0.90630779  0.        ]]\n\n\n<matplotlib.image.AxesImage at 0x7fd824494280>"
  },
  {
    "objectID": "GeometricTransformations.html#affine-transformations-skew",
    "href": "GeometricTransformations.html#affine-transformations-skew",
    "title": "2  Geometric Transformations",
    "section": "2.4 Affine transformations (skew)",
    "text": "2.4 Affine transformations (skew)\nImage\n\\[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22} \\\\\n\\end{bmatrix}\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n+\n\\begin{bmatrix} t_1 \\\\ t_2 \\end{bmatrix}\n\\] or \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} & a_{12} & t_1\\\\\na_{21} & a_{22} & t_2\\\\\n0 & 0 & 1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\n\\]\n\nTranslation: \\(\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\) ends up at location \\(\\begin{bmatrix} t_1 \\\\ t_2 \\end{bmatrix}\\)\n6 unknowns: you need 3 pairs of points to define a skew"
  },
  {
    "objectID": "GeometricTransformations.html#affine-transformation-sample",
    "href": "GeometricTransformations.html#affine-transformation-sample",
    "title": "2  Geometric Transformations",
    "section": "2.5 Affine transformation: Sample",
    "text": "2.5 Affine transformation: Sample\n\n# Define pairs of points\n# point = (x, y) ; [511, 0] = top right\npoints_src = np.float32([[0,0], [511, 0], [0, 511]])\npoints_dst = np.float32([[0,0], [300, 100], [200, 511]])\n\naffine_mat = cv2.getAffineTransform(points_src, points_dst)\nIaff = cv2.warpAffine(I, affine_mat, I.shape[1::-1], flags=cv2.INTER_LINEAR)\n\nprint(f\"Affine transformation matrix is {affine_mat}\")\nplt.imshow(Iaff)\n\nAffine transformation matrix is [[0.58708415 0.39138943 0.        ]\n [0.19569472 1.         0.        ]]\n\n\n<matplotlib.image.AxesImage at 0x7fd827f13fd0>\n\n\n\n\n\nExample: https://theailearner.com/tag/cv2-getaffinetransform/"
  },
  {
    "objectID": "GeometricTransformations.html#application-image-morphing",
    "href": "GeometricTransformations.html#application-image-morphing",
    "title": "2  Geometric Transformations",
    "section": "2.6 Application: Image morphing",
    "text": "2.6 Application: Image morphing\n\n\n\nFace morphing\n\n\n\nDefine point correspondences\nDecompose source image in triangles\nCompute affine transforms and warp every src triangle -> dst triangle\nReassemble output image\n\nSource: https://stackoverflow.com/a/65452859\nAlso: https://devendrapratapyadav.github.io/FaceMorphing/"
  },
  {
    "objectID": "GeometricTransformations.html#perspective-transformations",
    "href": "GeometricTransformations.html#perspective-transformations",
    "title": "2  Geometric Transformations",
    "section": "2.7 Perspective transformations",
    "text": "2.7 Perspective transformations\nImage\nStep 1: \\[\\begin{bmatrix} x' \\\\ y' \\\\ w \\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} & a_{12} & t_1\\\\\na_{21} & a_{22} & t_2\\\\\na_{31} & a_{32} & 1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\n\\]\nStep 2: divide by \\(w\\): \\[\n\\begin{bmatrix} x' \\\\ y' \\\\ w \\end{bmatrix}\n\\rightarrow\n\\begin{bmatrix} x'/w \\\\ y'/w \\\\ 1 \\end{bmatrix}\n\\]\n\n8 unknowns: you need 4 pairs of points to define perspective"
  },
  {
    "objectID": "GeometricTransformations.html#perspective-transformation-sample",
    "href": "GeometricTransformations.html#perspective-transformation-sample",
    "title": "2  Geometric Transformations",
    "section": "2.8 Perspective transformation: Sample",
    "text": "2.8 Perspective transformation: Sample\n\n# Define pairs of points\n# point = (x, y) ; [511, 0] = top right\npoints_src = np.float32([[0,0],    [511, 0],  [0, 511],   [511, 511]])\npoints_dst = np.float32([[200,50], [300, 50], [50, 411], [461, 411]])\n\npersp_mat = cv2.getPerspectiveTransform(points_src, points_dst, cv2.DECOMP_LU)\nIpersp = cv2.warpPerspective(I, persp_mat, I.shape[1::-1], flags=cv2.INTER_LINEAR)\n\nprint(f\"Perspective transformation matrix is {persp_mat}\")\nplt.imshow(Ipersp)\n\nPerspective transformation matrix is [[ 1.95694716e-01 -3.67582289e-01  2.00000000e+02]\n [ 0.00000000e+00  9.78473581e-02  5.00000000e+01]\n [-0.00000000e+00 -1.48080430e-03  1.00000000e+00]]\n\n\n<matplotlib.image.AxesImage at 0x7fd827e83250>\n\n\n\n\n\nSee here: https://theailearner.com/tag/cv2-getperspectivetransform/"
  },
  {
    "objectID": "GeometricTransformations.html#how-do-these-functions-work",
    "href": "GeometricTransformations.html#how-do-these-functions-work",
    "title": "2  Geometric Transformations",
    "section": "2.9 How do these functions work?",
    "text": "2.9 How do these functions work?\n\nFind the inverse transformation \\[\n\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\n\\rightarrow  \n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n\\]\nFor each destination location \\(\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\\):\n\nFind the source location \\(\\begin{bmatrix} x \\\\ y \\end{bmatrix}\\)\n\\(x\\) and \\(y\\) may not be integers, so interpolate"
  },
  {
    "objectID": "GeometricTransformations.html#bilinear-interploation",
    "href": "GeometricTransformations.html#bilinear-interploation",
    "title": "2  Geometric Transformations",
    "section": "2.10 Bilinear interploation",
    "text": "2.10 Bilinear interploation\n\n\n\nBilinear interpolation\n\n\n\nInterpolate the value based on the 4 neighbors\nSource: Wikipedia\nImage: By Cmglee - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=21409164"
  },
  {
    "objectID": "LinearFiltering.html",
    "href": "LinearFiltering.html",
    "title": "3  Linear Filtering",
    "section": "",
    "text": "Convolution = linear combination of pixel values around current position\n\n\n\n\n2D Convolution\n\n\n\nImage from http://machinelearninguru.com\nSee here: http://machinelearninguru.com/computer_vision/basics/convolution/convolution_layer.html\n\n\n\n\n\nSee here: \n\n\n\n\\[\nH = \\begin{bmatrix}\n\\frac{1}{9} & \\frac{1}{9} & \\frac{1}{9} \\\\\n\\frac{1}{9} & \\frac{1}{9} & \\frac{1}{9} \\\\\n\\frac{1}{9} & \\frac{1}{9} & \\frac{1}{9} \\\\\n\\end{bmatrix}\n\\]\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy as sp\nimport scipy.signal\nimport skimage.color\n\nI = cv2.imread('img/lena512.bmp')\n\n# Make original image grayscale\n# Take care: OpenCV images are BGR, not RGB. Must convert\nI = cv2.cvtColor(I, cv2.COLOR_BGR2RGB)\nI = skimage.color.rgb2gray(I)\n\n# Define convolution kernel\nH = np.array([[1/9, 1/9, 1/9], [1/9, 1/9, 1/9], [1/9, 1/9, 1/9]])\n\n# Apply convolution\nIblur = sp.signal.convolve2d(I, H, mode=\"same\")\n\nf, axarr = plt.subplots(1,2)\naxarr[0].imshow(I,  cmap='gray')\naxarr[1].imshow(Iblur, cmap='gray')\n\n/home/runner/.local/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version >=1.16.5 and <1.23.0 is required for this version of SciPy (detected version 1.23.3\n  warnings.warn(f\"A NumPy version >={np_minversion} and <{np_maxversion}\"\n\n\n<matplotlib.image.AxesImage at 0x7faf545a2790>\n\n\n\n\n\n\n\n\n\\[I \\ast H \\ast H \\ast H\\]\n\nIblur2 = sp.signal.convolve2d(Iblur, H, mode=\"same\")\nIblur3 = sp.signal.convolve2d(Iblur2, H, mode=\"same\")\n\nplt.imshow(I,  cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf513d6820>\n\n\n\n\n\n\nplt.imshow(Iblur,  cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf513bfeb0>\n\n\n\n\n\n\nplt.imshow(Iblur2, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf51324160>\n\n\n\n\n\n\nplt.imshow(Iblur3, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf5130e340>\n\n\n\n\n\n\n\n\n\nLarge \\(H\\) matrix but values are decaying exponentially, following a Gaussian function centered in the middle\nParameters: \\(\\sigma\\)\n\n\\(\\sigma\\) small = weak blurring\n\\(\\sigma\\) large = strong blurring\n\n\n\nimport scipy.ndimage\nfrom ipywidgets import interact, interact_manual\n\n@interact(sigma=(0.01, 10, 0.1))\ndef do_gauss_filter(sigma):\n  Igauss = scipy.ndimage.gaussian_filter(I, sigma)\n  plt.imshow(Igauss, cmap='gray')\n\n\n\n\n\n\n\n\\[\nH = \\begin{bmatrix}\n-1 & -1 & -1 \\\\\n-1 &  +1 & -1 \\\\\n-1 & -1 & -1 \\\\\n\\end{bmatrix}\n\\]\n\n# Define convolution kernel\nH = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])\n\n# Apply convolution\nIedge = sp.signal.convolve2d(I, H, mode=\"same\")\nplt.imshow(Iedge, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf511422b0>\n\n\n\n\n\n\n\n\n\nSobel: apply two filters and combine results\n\n\\[\nH_1 = \\begin{bmatrix}\n1 & 0 & -1 \\\\\n2 & 0 & -2 \\\\\n1 & 0 & -1 \\\\\n\\end{bmatrix}\n\\;\\;\\;\\;\nH_2 = \\begin{bmatrix}\n1 & 2 & 1 \\\\\n0 & 0 & 0 \\\\\n-1 & -2 & -1 \\\\\n\\end{bmatrix}\n\\]\n\n# Apply convolution\nIsobel = sp.ndimage.sobel(I)\nplt.imshow(Isobel, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf5109de80>\n\n\n\n\n\nThe background is grayscale because the convolution results are both positive and negative, and the plotting rescales the 0 value at the middle (128 = gray).\nIf plot the absolute values we get:\n\nplt.imshow(np.abs(Isobel), cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf5107fe50>\n\n\n\n\n\n\n\n\n\nfrom matplotlib.colors import Normalize\n\n# Define convolution kernel\nH = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n\n# Apply convolution\nIsharp = sp.signal.convolve2d(I, H, mode=\"same\")\nplt.imshow(Isharp, cmap='gray', norm=Normalize(0,1))\n\n<matplotlib.image.AxesImage at 0x7faf50fe77c0>\n\n\n\n\n\nRepeat:\n\nIsharp2 = sp.signal.convolve2d(Isharp, H, mode=\"same\")\nplt.imshow(Isharp2, cmap='gray', norm=Normalize(0,1))\n\n<matplotlib.image.AxesImage at 0x7faf50fd0250>\n\n\n\n\n\n\nIsharp3 = sp.signal.convolve2d(Isharp2, H, mode=\"same\")\nplt.imshow(Isharp3, cmap='gray', norm=Normalize(0,1))\n\n<matplotlib.image.AxesImage at 0x7faf50d33250>\n\n\n\n\n\n\n\n\n\nMathematical operations might lead to values outside \\([0,1]\\) => make sure to normaliza data when needed\nSharpening noisy data increases the noise!\n\n\n\n\n\nReplace a pixel with the median value in a local window surrounding it.\nImage\n\nImedian = sp.signal.medfilt2d(I, 3)\nplt.imshow(Imedian, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf50c96160>\n\n\n\n\n\n\nplt.imshow(I, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7faf50c79100>"
  },
  {
    "objectID": "Binarization.html",
    "href": "Binarization.html",
    "title": "4  Binarization",
    "section": "",
    "text": "This chapter deals with hrayscale images\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy as sp\nimport scipy.signal\nimport skimage.io\nimport skimage.color\nimport skimage.exposure\nfrom ipywidgets import interact\n\n#I = skimage.data.astronaut()\nI = skimage.io.imread('img/Trees.jpg')\nplt.imshow(I)\n\n/home/runner/.local/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version >=1.16.5 and <1.23.0 is required for this version of SciPy (detected version 1.23.3\n  warnings.warn(f\"A NumPy version >={np_minversion} and <{np_maxversion}\"\n\n\n<matplotlib.image.AxesImage at 0x7f3de0e2ab20>\n\n\n\n\n\n\nI = skimage.color.rgb2gray(I)\nplt.imshow(I, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3dde8f1dc0>"
  },
  {
    "objectID": "Binarization.html#image-histogram",
    "href": "Binarization.html#image-histogram",
    "title": "4  Binarization",
    "section": "4.2 Image histogram",
    "text": "4.2 Image histogram\nHistogram = the number of occurrences of every pixel value\n\n_,_,_=plt.hist(I.ravel(), bins=256)"
  },
  {
    "objectID": "Binarization.html#histogram-equalization",
    "href": "Binarization.html#histogram-equalization",
    "title": "4  Binarization",
    "section": "4.3 Histogram equalization",
    "text": "4.3 Histogram equalization\nHistogram equalization:\n\narrange all pixels in order, from smallest to largest\nset pixel value proportional to position of pixel in list\n\ndarkest pixel becomes 0\nwhitest pixed becomes 255\nthe median pixel becomes 127\n…\n\n\nAdvantage:\n\nIncrease contrast\n\n\nplt.imshow(I, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3de0b5c7c0>\n\n\n\n\n\n\nIheq = skimage.exposure.equalize_hist(I)\nplt.imshow(Iheq, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3de0ac8280>\n\n\n\n\n\nOriginal histogram:\n\n_,_,_=plt.hist(I.ravel(), bins=256)\n\n\n\n\nFinal histogram:\n\n_,_,_=plt.hist(Iheq.ravel(), bins=256)"
  },
  {
    "objectID": "Binarization.html#adaptive-local-histogram-equalization",
    "href": "Binarization.html#adaptive-local-histogram-equalization",
    "title": "4  Binarization",
    "section": "4.4 Adaptive (local) histogram equalization",
    "text": "4.4 Adaptive (local) histogram equalization\n\nApply hist. eq. based on a local window around current position\n\nAdvantage:\n\nimages with unequal illumination\n\n\nP = skimage.data.page()\nplt.imshow(P, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3dde4a4d30>\n\n\n\n\n\n\nPheq = skimage.exposure.equalize_hist(P)\nplt.imshow(Pheq, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3de0c1d940>\n\n\n\n\n\n\nPheqadapt = skimage.exposure.equalize_adapthist(P)\nplt.imshow(Pheqadapt, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3dde40c700>\n\n\n\n\n\n\n_,_,_=plt.hist(Pheqadapt.ravel(), bins=256)"
  },
  {
    "objectID": "Binarization.html#thresholding",
    "href": "Binarization.html#thresholding",
    "title": "4  Binarization",
    "section": "4.5 Thresholding",
    "text": "4.5 Thresholding\n= Make image binary, by comparing with a threshold T\n\\(T = 128\\)\n\nplt.imshow(P > 128, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3de0c1f910>\n\n\n\n\n\n\\(T = 0.7\\)\n\nplt.imshow(P > 165, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3de09d2250>\n\n\n\n\n\n\n@interact(T=(0,255,1))\ndef thresh(T):\n  plt.imshow(P > T, cmap='gray')\n\n\n\n\nThresholding the image after histogram adaptive equalziation:\n\nplt.imshow(Pheqadapt > 0.3, cmap='gray')\n\n<matplotlib.image.AxesImage at 0x7f3dde11b640>\n\n\n\n\n\n\n@interact(T=(0,1,0.01))\ndef thresh(T):\n  plt.imshow(Pheqadapt > T, cmap='gray')"
  },
  {
    "objectID": "Binarization.html#automatic-thresholding-with-otsus-method",
    "href": "Binarization.html#automatic-thresholding-with-otsus-method",
    "title": "4  Binarization",
    "section": "4.6 Automatic thresholding with Otsu’s method",
    "text": "4.6 Automatic thresholding with Otsu’s method\n\nFind threshold such as to minimize intra-class variance\n\nequivalently, maximize inter-class variance\n\n\n\n\n\nOtsu’s method explanation\n\n\n::: {.cell execution_count=17} ``` {.python .cell-code} from skimage.filters import threshold_otsu\nT_Otsu = threshold_otsu(Pheqadapt) print(f”Threshold found by Otsu method = {T_Otsu}“) plt.imshow(Pheqadapt > T_Otsu, cmap=‘gray’) ```\n::: {.cell-output .cell-output-stdout} Threshold found by Otsu method = 0.572265625 :::\n::: {.cell-output .cell-output-display execution_count=17} <matplotlib.image.AxesImage at 0x7f3dde4e0f40> :::\n::: {.cell-output .cell-output-display}  ::: :::"
  },
  {
    "objectID": "Binarization.html#adaptive-thresholding",
    "href": "Binarization.html#adaptive-thresholding",
    "title": "4  Binarization",
    "section": "4.7 Adaptive thresholding",
    "text": "4.7 Adaptive thresholding\n\nFind threshold based only on the surrounding region of a pixel\n\ncan use any method: mean value of region, Otsu, etc\n\nthreshold_local() from skimage package: specify region size, and an offset to subtract from region mean\n\n\nfrom skimage.filters import threshold_local\n\ndef thresh_local(block_size=25, offset=0.1):\n  Tadapt = threshold_local(Pheqadapt, block_size=block_size, offset=offset)\n  plt.imshow(Pheqadapt > Tadapt, cmap='gray')\n  return np.array(Pheqadapt > Tadapt, dtype=np.int)\n\nPthr = thresh_local()\n\nskimage.io.imsave('img/PageBinary.png', Pthr, check_contrast=False)\n\n/tmp/ipykernel_2258/2171965942.py:6: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.\nDeprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations\n  return np.array(Pheqadapt > Tadapt, dtype=np.int)\nLossy conversion from int64 to uint8. Range [0, 1]. Convert image to uint8 prior to saving to suppress this warning.\n\n\n\n\n\nInteractive:\n\nfrom skimage.filters import threshold_local\n\n@interact(block_size=(3, 128, 2), offset=(-0.2, 0.2, 0.01))\ndef thresh_local(block_size, offset):\n  Tadapt = threshold_local(Pheqadapt, block_size=block_size, offset=offset)\n  plt.imshow(Pheqadapt > Tadapt, cmap='gray')"
  },
  {
    "objectID": "MorphologicalOperations.html",
    "href": "MorphologicalOperations.html",
    "title": "5  Morphological Operations",
    "section": "",
    "text": "Operations on binary images to fill in small gaps, eliminate spurious points."
  },
  {
    "objectID": "MorphologicalOperations.html#sample-image",
    "href": "MorphologicalOperations.html#sample-image",
    "title": "5  Morphological Operations",
    "section": "5.2 Sample image",
    "text": "5.2 Sample image\nLet’s start from a binary image:\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy as sp\nimport scipy.signal\nimport skimage.io\nimport skimage.color\nimport skimage.exposure\nfrom ipywidgets import interact\n\nI = skimage.io.imread('img/MorphoImage.jpg')\nI = skimage.color.rgb2gray(I)\nprint(I)\nI = (I > 0.5).astype('uint8')\nplt.imshow(I, cmap='gray')\n\n/home/runner/.local/lib/python3.8/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version >=1.16.5 and <1.23.0 is required for this version of SciPy (detected version 1.23.3\n  warnings.warn(f\"A NumPy version >={np_minversion} and <{np_maxversion}\"\n\n\n[[0.99215686 1.         0.96470588 ... 1.         1.         1.        ]\n [0.97254902 1.         0.99215686 ... 0.95294118 1.         1.        ]\n [0.97254902 1.         0.10980392 ... 1.         0.97647059 0.92156863]\n ...\n [1.         0.95294118 0.30588235 ... 0.75686275 0.95294118 1.        ]\n [0.94117647 0.99215686 0.92941176 ... 1.         0.99215686 1.        ]\n [1.         0.99215686 1.         ... 1.         0.94901961 1.        ]]\n\n\n<matplotlib.image.AxesImage at 0x7fecd58840d0>"
  },
  {
    "objectID": "MorphologicalOperations.html#operations",
    "href": "MorphologicalOperations.html#operations",
    "title": "5  Morphological Operations",
    "section": "5.3 Operations",
    "text": "5.3 Operations\n\nDilation\nErosion\nOpening\nClosing"
  },
  {
    "objectID": "MorphologicalOperations.html#dilation",
    "href": "MorphologicalOperations.html#dilation",
    "title": "5  Morphological Operations",
    "section": "5.4 Dilation",
    "text": "5.4 Dilation\nConsider a small structuring element, e.g. a disk of radius 3 px\nFor every black pixel in the image:\n\nPlace the structuring element on that position\nIf it overlaps with the object (white), turn it white\n\nDilation grows objects and eliminates small gaps\n\n\n\nDilation\n\n\n\nimport skimage.morphology\n\nelem = skimage.morphology.disk(2)\nIdil = skimage.morphology.dilation(I, elem)\nplt.imshow(Idil, cmap=plt.cm.gray)\n\n<matplotlib.image.AxesImage at 0x7feccf668310>\n\n\n\n\n\nInteractive:\n\n@interact(radius=(1,10,1))\ndef dil(radius):\n  elem = skimage.morphology.disk(radius)\n  Idil = skimage.morphology.dilation(I, elem)\n  plt.imshow(Idil, cmap=plt.cm.gray)"
  },
  {
    "objectID": "MorphologicalOperations.html#erosion",
    "href": "MorphologicalOperations.html#erosion",
    "title": "5  Morphological Operations",
    "section": "5.5 Erosion",
    "text": "5.5 Erosion\nShrink the object:\n\nput the disk on every white pixel in the image\nkeep pixel only if the disk is fully inside the object\notherwise, turn pixel to black\n\nErosion shrinks objects and eliminates spurious small points.\n\n\n\nErosion\n\n\n\nIers = skimage.morphology.erosion(I, elem)\nplt.imshow(Iers, cmap=plt.cm.gray)\n\n<matplotlib.image.AxesImage at 0x7feccf558670>\n\n\n\n\n\nInteractive:\n\n@interact(radius=(1,10,1))\ndef ers(radius):\n  elem = skimage.morphology.disk(radius)\n  Iers = skimage.morphology.erosion(I, elem)\n  plt.imshow(Iers, cmap=plt.cm.gray)"
  },
  {
    "objectID": "MorphologicalOperations.html#opening",
    "href": "MorphologicalOperations.html#opening",
    "title": "5  Morphological Operations",
    "section": "5.6 Opening",
    "text": "5.6 Opening\nOpening = Erosion followed by Dilation\nSmall objects are removed\n\nIopen = skimage.morphology.opening(I, elem)\nplt.imshow(Iopen, cmap=plt.cm.gray)\n\n<matplotlib.image.AxesImage at 0x7feccf4b3460>\n\n\n\n\n\nInteractive:\n\n@interact(radius=(1,10,1))\ndef opn(radius):\n  elem = skimage.morphology.disk(radius)\n  Iopen = skimage.morphology.opening(I, elem)\n  plt.imshow(Iopen, cmap=plt.cm.gray)"
  },
  {
    "objectID": "MorphologicalOperations.html#closing",
    "href": "MorphologicalOperations.html#closing",
    "title": "5  Morphological Operations",
    "section": "5.7 Closing",
    "text": "5.7 Closing\nClosing = Dilation followed by Erosion\nSmall gaps are removed\n\nIclose = skimage.morphology.closing(I, elem)\nplt.imshow(Iclose, cmap=plt.cm.gray)\n\n<matplotlib.image.AxesImage at 0x7feccf403f40>\n\n\n\n\n\nInteractive:\n\n@interact(radius=(1,10,1))\ndef clos(radius):\n  elem = skimage.morphology.disk(radius)\n  Iclose = skimage.morphology.closing(I, elem)\n  plt.imshow(Iclose, cmap=plt.cm.gray)"
  },
  {
    "objectID": "MorphologicalOperations.html#sequence",
    "href": "MorphologicalOperations.html#sequence",
    "title": "5  Morphological Operations",
    "section": "5.8 Sequence",
    "text": "5.8 Sequence\nLet’s try an opening + closing\n\nelem = skimage.morphology.disk(3)\nIopen = skimage.morphology.opening(I, elem)\nplt.imshow(Iopen, cmap=plt.cm.gray)\nIclose = skimage.morphology.closing(Iopen, elem)\nplt.imshow(Iclose, cmap=plt.cm.gray)\n\n<matplotlib.image.AxesImage at 0x7feccf2ed310>"
  },
  {
    "objectID": "MorphologicalOperations.html#other-operations",
    "href": "MorphologicalOperations.html#other-operations",
    "title": "5  Morphological Operations",
    "section": "5.9 Other operations",
    "text": "5.9 Other operations\nSee here:"
  }
]